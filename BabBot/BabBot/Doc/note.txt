Various notes and snippets of code that will be handy later on..


you can use "/script RepopMe()" to click the release button, then do "/script RetrieveCorpse()" 
when you're within 30 yards. these are functions built into the game so you dont have to 
worry about calculating where the buttons to click are based on the current resolution.


Player dead if health value == 0
After that player is ghost if health value == 1



When your health == 0, save your current x,y,z to variables, then waypoint to those points 
until distance to that point <= 30 yards and no enemy is within 20 yards (randomly walk around until #2 is true).



public static CorpseObject[] GetCorpseObjects(IntPtr hProcess)
        {
            Object[] Objects = GetObjects(hProcess);

            List<CorpseObject> Corpses = new List<CorpseObject>();
            for (int i = 0; i < Objects.Length; i++)
            {

                if (Objects[i].OBJECT_FIELD_TYPE == (int)eObjectType.CORPSE)
                {
                        float x = MemoryLib.Memory.ReadFloat(hProcess,
                           (MemoryLib.Memory.ReadUInt(hProcess, Objects[i].OBJECT_FIELD_BASEADRESS + 0x08) + (int)eCorpseFields.CORPSE_FIELD_POS_X));

                        float y = MemoryLib.Memory.ReadFloat(hProcess,
                           (MemoryLib.Memory.ReadUInt(hProcess, Objects[i].OBJECT_FIELD_BASEADRESS + 0x08) + (int)eCorpseFields.CORPSE_FIELD_POS_Y));

                        float z = MemoryLib.Memory.ReadFloat(hProcess,
                           (MemoryLib.Memory.ReadUInt(hProcess, Objects[i].OBJECT_FIELD_BASEADRESS + 0x08) + (int)eCorpseFields.CORPSE_FIELD_POS_Z));

                        float facing = MemoryLib.Memory.ReadFloat(hProcess,
                           (MemoryLib.Memory.ReadUInt(hProcess, Objects[i].OBJECT_FIELD_BASEADRESS + 0x08) + (int)eCorpseFields.CORPSE_FIELD_FACING));

                        UInt64 owner = MemoryLib.Memory.ReadUInt64(hProcess,
                           (MemoryLib.Memory.ReadUInt(hProcess, Objects[i].OBJECT_FIELD_BASEADRESS + 0x08) + (int)eCorpseFields.CORPSE_FIELD_OWNER));

                        CorpseObject tempCorpse = new CorpseObject();
                        tempCorpse.CORPSE_FIELD_POS_X = x;
                        tempCorpse.CORPSE_FIELD_POS_Y = y;
                        tempCorpse.CORPSE_FIELD_POS_Z = z;
                        tempCorpse.CORPSE_FIELD_FACING = facing;
                        tempCorpse.CORPSE_FIELD_OWNER = owner;

                        Corpses.Add(tempCorpse);
                }
            }
            CorpseObject[] retVector = new CorpseObject[Corpses.Count];
            Corpses.CopyTo(retVector);

            return retVector;
        }




Lista completa dei descrittori mancanti in quello attuale (anche se questi sono vecchi):
http://www.nomorepasting.com/getpaste.php?pasteid=17404



[[objectaddress+0x8]+0x17*4]
Explanation: read object base + 8 for a pointer to UNIT_FIELDS. 
If you check the post unit fields health is 0x17, you read from unit fields + 0x17 multiplied by 4 because 
each array slot* is 4 bytes.




http://www.mmowned.com/forums/wow-memory-editing/208754-guide-kind-how-i-handle-objects.html
Spiegazione dettagliata di come funziona l'ObjectMAnager di WoW


http://www.wowwiki.com/API_TargetUnit
http://www.wowwiki.com/API_ClearTarget


To attack with the melee attack by script:
Slightly longer, but more complete method to just find attack anywhere on your bar.

/script if not ma then for i = 1,72 do if IsAttackAction(i) then ma = i; end; end; end; if ma then if not IsCurrentAction(ma) then UseAction(ma); end; else AttackTarget("target");end; 


Modified version of Pather which could be used to calculate paths only:
http://www.mmowned.com/forums/bots-programs/180772-source-ppather-pathfinder-your-own-programs.html


To loot, let's have the end user set the "Interact with Target" hotkey in WoW and use that one. We first have to 
select the corpse of course. That can be used for vendoring and repairing. Having auto-loot on will get rid of having to
click with the mouse on the stuff we are looting

More stuff about pathing from MPQ files: http://www.mpqnav.com


Stuff on Finite State Machines
http://www.mmowned.com/forums/c/232703-bot-developers-simple-but-effective-fsm-your-bots.html


UNIT_NPC_FLAGS
0x1: conversation
0x2: involved in a quest
0x10: trainer
0x20: ...for your class (not always set :-( )
0x40: ...for your professions (all professions if you have not yet chosen your 2) 
0x80: vendor
0x100: general goods, bowyer (unsure)
0x200: food, drink (unsure)
0x800: reagents (unsure)
0x1000: repair
0x2000: gryphon master etc.
0x10000: innkeeper
0x20000: banker
0x80000: tabard vendor
0xC0000: guild master
0x100000: battle master
0x200000: auctioneer
0x400000: stable master


Movement Types:
(8byte) Thanks to testout

0x1 = Moving Forward
0x2 = Moving Backward
0x4 = Strafing Left
0x8 = Strafing Right
0x10 = Turning Left
0x20 = Turning Right
0x100 = Walking
0x1000 = Dead
0x4000 = Fall Forwards
0x8000 = Fall Backwards
0x2000 = Freefall/Jumping
0x10000 = Strafing while jumping
0x200000 = Swimming
0x10000000 = Spirit Form
0x80000000 = Unknown


Mouse Types:
(4 bytes) Thanks to lunitune


Decimal value = description
1 = normal

3 = banker/auctioneer in range (money bag)
4 = attack in range
5 = use (fishing bobber) in range
6 = talk (cartoon chat bubble)

8 = money bags in range (merchant)

10 = trainer book in range
11 = mining in range
12 = skin in range
13 = herbalism in range
15 = mail in range
16 = loot in range
18 = repair in range

23 = quest giver ! in range
24 = repeatable quest giver in range (blue ?)

28 = banker/auctioneer/guild bank out of range (money bags)
29 = attack out of range
30 = use - out of range
31 = talk (cartoon chat bubble) - out of range

33 = money bags out of range (merchant)

35 = trainer book out of range
36 = mining out of range
37 = skin out of range
38 = herbalism out of range
40 = mail out of range
41 = loot out of range
43 = repair out of range

48 = Quest giver ! out of range
49 = repeatable quest giver out of range (blue ?)

51 = ask for directions out of range AND in range (scroll over guards)


PLAYER_TRACK_CREATURES:
None = 0
Beasts = 1
Dragonkin = 2
Demon = 4
Elemental = 8
Giant = 16
Undead = 32
Humanoid = 64
Critter = 128
Machines = 256
Not Specified(Slime, Those Green Eye Things, Random Invisible Crap) = 512 

PLAYER_TRACK_RESOURCES 
None = 0
??? = 1
Herbs = 2
Minerals = 4
??? = 8
Treasure = 16
Crate/Chest(Food Crate/Water Barol/Battered Chest) = 32
??? = 64
??? = 128
??? = 256
??? = 512
??? = 1024
??? = 2048
Crate/Chest2(Stolen Supply Crate/Gnomish Toolbox) =  4096


enum eTrack
{
    TRACK_BEASTS        = 0x01,
    TRACK_DRAGONS        = 0x02,
    TRACK_DEMONS        = 0x04,
    TRACK_ELEMENTALS    = 0x08,
    TRACK_GIANTS        = 0x10,
    TRACK_HUMANOIDS        = 0x40,
    TRACK_UNDEAD        = 0x20,
    TRACK_MACHINES        = 0x100,
    TRACK_SLIMES        = 0x200,
    TRACK_CRITTERS        = 0x80,
    TRACK_ALL            = -1,

    TRACK_OBJECT_HERBS            = 0x02,
    TRACK_OBJECT_MINERALS        = 0x04,
    TRACK_OBJECT_TREASURE        = 0x20,
    TRACK_OBJECT_ALL            = -1
};
Here's a cleaned up version of the above post, remembering that the tracking flags are bitmasks, to apply a tracking flag you simple do: Flags &= TRACK_WHATEVER;

To remove a tracking flag, use Flags &= ~TRACK_WHATEVER;
To check for a flag, use Flags & TRACK_WHATEVER;


       public Mover(LocalPlayer Me)
        {
            const uint GetContinentName = 0x010A51F8;
            string contintentName = Game.wow.ReadUTF8String(GetContinentName, 40);
            ppather.Init(contintentName);
            this.Me = Me;
            mySpot.Update(Me.Location);
            Logger.logToFile("PPather started on " + contintentName + ".");
        }





3.1.2
DoString:

Code:

 public void DoString(string strScript)
        {
            uint pScript = m_OM.WoW.AllocateMemory(0x3000);
            m_OM.WoW.WriteASCIIString(pScript, strScript);

            uint codeCave = m_OM.WoW.AllocateMemory(0x1024);

            m_OM.UpdateCurMgr();

            m_OM.WoW.Asm.AddLine("mov ecx, {0}", pScript + strScript.Length - 1);
            m_OM.WoW.Asm.AddLine("mov eax, " + pScript);

            m_OM.WoW.Asm.AddLine("push 0");
            m_OM.WoW.Asm.AddLine("push eax");
            m_OM.WoW.Asm.AddLine("push eax");

            m_OM.WoW.Asm.AddLine("mov eax, {0}", 0x0049AB60);
            m_OM.WoW.Asm.AddLine("call eax");
            m_OM.WoW.Asm.AddLine("add esp, 0xC");
            m_OM.WoW.Asm.AddLine("retn");

            m_OM.WoW.SuspendThread();
            m_OM.WoW.Asm.InjectAndExecute(codeCave);
            m_OM.WoW.FreeMemory(codeCave);
            m_OM.WoW.FreeMemory(pScript);
            m_OM.WoW.ResumeThread();
        }

GetLocalizedText:

Code:

public String GetLocalizedText(string variable)
        {
            uint codecave = m_OM.WoW.AllocateMemory(0x200);

            m_OM.WoW.WriteASCIIString(codecave + 0x100, variable);

            m_OM.WoW.Asm.Clear();

            m_OM.UpdateCurMgr();

            m_OM.Start(2500);

            m_OM.WoW.Asm.AddLine("mov ecx, {0}", m_OM.LocalPlayer.BaseAddress);
            m_OM.WoW.Asm.AddLine("push {0}", -1);
            m_OM.WoW.Asm.AddLine("push {0}", codecave + 0x100);
            m_OM.WoW.Asm.AddLine("call {0}", 0x005A8500);
            m_OM.WoW.Asm.AddLine("retn");

            m_OM.WoW.SuspendThread();

            uint result = m_OM.WoW.Asm.InjectAndExecute(codecave);

            String sResult = "null";
            if (result != 0)
            {
                sResult = m_OM.ReadString(result);
            }

            m_OM.WoW.FreeMemory(codecave);

            m_OM.WoW.ResumeThread();

            return sResult;
        }



To patch the function that checks for protected LUA functions:
The lua protection check function is located at 0x4A4480.

Code:

004A4480        /$  55               PUSH EBP
004A4481        |.  8BEC             MOV EBP,ESP
004A4483        |.  833D 40B42E01 00 CMP DWORD PTR DS:[12EB440],0
004A448A        |.  8B4D 08          MOV ECX,[ARG.1]                           ;  Wow.<ModuleEntryPoint>
004A448D        |.  A1 C0680A01      MOV EAX,DWORD PTR DS:[10A68C0]

To make this function always return true, you can just patch the very first opcodes to

mov eax,1
retn